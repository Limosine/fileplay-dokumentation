\documentclass[a4paper]{article}
\usepackage{graphicx}
\usepackage{pdfpages}
\usepackage{hyperref}
\usepackage{etoc}
\usepackage[ngerman]{babel}
\usepackage[T1]{fontenc}

% cSpell:words Filesharing techstack Dezhong Zhuang

\begin{document}


\input{Titelseite.tex}

\setcounter{tocdepth}{2}
\tableofcontents
\newpage

\section{Einleitung}
Unser Projekt ist eine Filesharing App (Webseite), mit der Dateien Peer-to-Peer,
also von Nutzer zu Nutzer, ohne zwischengeschalteten Server*, übertragen werden
können. Die App basiert auf modernen Web-Technologien, wie z.B.
\href{https://web.dev/push-notifications-web-push-protocol/}{Web Push},
\href{https://web.dev/learn/pwa/service-workers/}{Service Workers} und
\href{https://web.dev/progressive-web-apps/}{Progressive Web Apps}. Durch die
Design-Philosophie des
\href{https://developer.mozilla.org/en-US/docs/Glossary/Progressive_Enhancement}{Progressive
  Enhancement} werden aber auch ältere Browser unterstützt. Eine Besonderheit der
App ist es, dass sie dauerhafte Verbindungen durch Kontakte möglich macht.
Kontakte können zwischen mehreren Nutzern geknüpft werden, wobei jeder Nutzer
mehrere Geräte haben kann. Zum Schutz der Privatsphäre und Benutzersicherheit
werden keine identifizierbaren Informationen auf dem Server (in der Datenbank)
gespeichert und die Dateien im Transit Ende-zu-Ende verschlüsselt. Die
Motivation für dieses Projekt war das Problem, dass es keine einfache
Möglichkeit gibt, zwischen iOS / Android / Windows / Linux Geräten Dateien zu
teilen. Bestehende Webseiten nutzen hierfür einen Link, den der Empfänger öffnen
muss, um die Datei zu empfangen. Hierbei stellt sich dann wieder die Frage, wie
man diesen Link teilt. Um dieses Problem zu behandeln, implementiert die App ein
Kontakt-System, in dem sich Nutzer einmalig über einen 6-stelligen Code
verbinden und von nun an einfach miteinander Dateien teilen können. Dieses
System ist vor allem in einer Umgebung nützlich, in der man oft Dokumente mit
denselben Personen teilt, wie es z.B. in der Schule der Fall ist.

\section{Dokumentation}

\subsection{Implementierung}
Die App wurde in Form einer Webseite realisiert und ist somit auf allen Geräten
zugänglich, die einen Browser haben. Für die Entwicklung haben wir uns für das
Framework \href{https://kit.svelte.dev/}{SvelteKit} im NodeJS Ökosystem
entschieden. Dadurch muss die App nicht manuell in den Browser-kompatiblen
Sprachen geschrieben werden, sondern kann in einer modernen Sprache (Svelte in
Verbindung mit Typescript) geschrieben werden, wodurch die Entwicklung durch
vorgefertigte Implementierungsmuster und Tools stark vereinfacht wird. Die App
ist nach dem Muster einer Single-Page-Application aufgebaut, d.h. die Seite wird
nur einmal geladen, und alle weiteren Interaktionen finden über JavaScript
statt. Dadurch wird die App sehr schnell, da nur die Daten, die benötigt werden,
vom Server geladen werden müssen. Zusätzlich wird die App dadurch sehr
benutzerfreundlich, da der Nutzer nicht durch das Laden von verschiedenen Seiten
unterbrochen wird. Durch die optionale Installation als Progressive Web App
(PWA) kann die App auch auf dem Homescreen installiert werden, und verhält sich
dann wie eine native App.\\
Die Entwicklung der App findet in einer öffentlichen GitHub Repository statt.
Dieses Repository ist unter \url{https://github.com/leonhma/fileplay} zu finden,
und wird automatisch durch Integration mit Cloudflare auf den Adressen
\url{https://app.fileplay.me} (für den {main}-branch) und
\url{https://dev.fileplay.pages.dev} (für den {dev}-branch) zur Verfügung gestellt.\\
Der Programmcode für einen Microservice der die Kommunikation von Server zu
Client verwaltet ist unter \\\url{https://github.com/leonhma/fileplay-worker} zu
finden. Dieser Mikroservice nutzt APIs die nicht in SvelteKit verfügbar sind,
und wird deshalb separat gehosted.

\subsection{Architektur}
Die App ist nach dem MVC-Modell in drei Teile aufgeteilt: Frontend, Backend und
Datenbank. Das Frontend (View) ist die Webseite, die der Nutzer sieht und mit
der er interagiert. Das Backend (Controller) ist der Server, der die Webseite
ausliefert und die Anwendungslogik verwaltet, und die Datenbank ist das Modell,
in dem die Daten gespeichert werden. Sowohl das Frontend, als auch große Teile
des Backends werden vom Framework SvelteKit verwaltet. Dieses Framework erlaubt
es, die Webseite mit einer angepassten Syntax zu schreiben und
Entwickler-freundlich in Komponenten zu zerteilen. Zusätzlich bietet es eine
einfache Möglichkeit, Backend und Frontend Seite an Seite zu entwickeln.
Zusätzlich zu dem Backend-Code, der in SvelteKit geschrieben ist, gibt es noch
einen Microservice, der als \href{https://workers.cloudflare.com/}{Cloudflare
  Worker} mithilfe von Typescript geschrieben wurde. Dieser verwaltet die WebSockets, die für
die Kommunikation von Server zu Client verwendet werden. Die Datenbank ist eine
SQLite Datenbank, welche mit dem Backend verbunden ist und Daten wie Geräte, Nutzer
oder Kontakte speichert.\\
Die einzelnen Teile der App (Backend, Datenbank und Microservice) werden alle
auf Cloudflare gehosted. Cloudflare bietet verschieden Web-Hosting-Services an,
darunter auch Pages, welches über eine GitHub Integration einfach mit dem
Build-Output von SvelteKit verbunden werden kann. Zusätzlich wird eine SQLite
Datenbank namens D1 verwendet, welche im Backend einfach durch Umgebungsvariablen
eingebunden werden kann. Der Microservice ist ein Cloudflare Worker, welcher
mithilfe der neuen WebSocket Hibernation API ressourcenschonend die Verbindungen
von Server zu Client verwaltet.\\
Die clientseitige Logik der App findet vor allem in Form von JavaScript
clientseitig statt. Wenn Daten vom Server abgefragt werden müssen, wie zum
Beispiel die Liste der Kontakte, wird dies über eine REST API gemacht. Dagegen findet
die Kommunikation von Server zu Client über WebSockets statt. Alternativ wird
hier auch eine Implementierung mit Web Push verwendet, jedoch wurde diese
aufgrund von Kompatibilitätsproblemen mit Edge und Firefox kurzfristig
deaktiviert. Die Dateiübertragung zwischen zwei Clients findet über WebRTC
statt. So kann die Datei (bis auf die Ausnahme einer Firewall) direkt zwischen
zwei Clients übertragen werden. Zwischen dem Front- und Backend steht noch ein
Service Worker, der im Browser der Nutzers läuft. Dieser ist für das Empfangen
von Nachrichten des Servers, und das cachen von Dateien zuständig.


\subsection{Authentifizierung}

Beim ersten Besuch der Webseite wird der Nutzer aufgefordert, bei der
Einrichtung einen Name für das Gerät und den verbundenen Nutzer einzugeben.
Diese Informationen werden dann an den Server gesendet, welcher dem Gerät eine
einzigartige Device ID zuweist. Diese ID wird dann in einem Cookie gespeichert,
und bei weiteren Besuchen der Webseite an den Server gesendet. Der Server kann
dann durch diese ID das Gerät identifizieren, und die Daten des Geräts aus der
Datenbank laden.\\
Um zu verhindern, dass ein Nutzer sich als ein anderes Gerät ausgibt, wird
zusätzlich zur Device ID ein Token generiert, welches auch einem Cookie
gespeichert wird. Dieses Token wird bei jeder Anfrage an den Server gesendet,
und der Server kann dann überprüfen, ob das Token, das mit der Signatur des
Servers unterzeichnet wurde, zu der Device ID passt.

\subsection{Geräte, Nutzer, Kontakte}

Um eine einfache Organisation und Nutzung der App zu ermöglichen, wird zwischen Geräten,
Nutzern und Kontakten unterschieden. Ein Gerät ist ein Endgerät, auf dem die App
installiert ist. Ein Nutzer ist eine Person, die die App nutzt. Ein Nutzer kann
mehrere Geräte besitzen, ein Gerät dagegen kann nur einem Nutzer zugeordnet werden. Ein Kontakt repräsentiert
eine Verbindung zwischen zwei Nutzern, welche wiederum unbegrenzt viele Kontakte haben können.\\
Diese Verknüpfungen von Nutzern und Geräten (one-to-many) und Nutzern
untereinander, als Kontakte (many-to-many), können durch das Generieren und
Einlösen von sechsstelligen Verbindungscodes realisiert werden. Wenn ein Nutzer
einen Code generiert, wird dieser Code in der Datenbank gespeichert und kann diesen
Code an einen anderen Nutzer weitergeben. Wenn der andere
Nutzer diesen Code eingibt, wird eine Verbindung zwischen den beiden Nutzern
hergestellt und der Code wird aus der Datenbank gelöscht.


\subsection{Filesharing}
Wenn ein Nutzer eine Datei teilen möchte, wählt er einen verfügbaren Kontakt
aus, dessen ID dann in einer Anfrage an den Server gesendet wird. Dieser schickt
diese Anfrage anschließend per WebSocket (oder Web Push) an die einzelnen Geräte des
Kontakts. Wenn ein Gerät die Anfrage akzeptiert, schickt dieses Gerät eine
Antwort mit der PeerJS-Adresse des Geräts, an das die Datei übertragen werden soll,
an den Server. Diese Antwort enthält auch den Public Key des Geräts, der für die
Verschlüsselung der Datei verwendet wird. Der Server leitet diese Antwort dann
an den ursprünglichen Nutzer weiter, der die Datei dann an die PeerJS-Adresse
senden kann.

\subsection{User-Story}

\subsubsection{Einrichtung}
Wenn ein Nutzer die App zum ersten Mal öffnet, wird er aufgefordert, einen Namen
für das Gerät anzugeben, und den Typ des Geräts auszuwählen. Dies dient lediglich
der erleichterten späteren Identifikation der Geräte durch den Nutzer selbst.\\
Zusätzlich zu den Daten des Geräts muss der Nutzer entweder einen neuen Nutzer erstellen,
oder das Gerät zu einem Bereits existierenden hinzufügen. Wenn der Nutzer einen neuen erstellt,
Kann er diesem einen Namen geben. Dieser Name wird auch für Kontakte sichtbar sein, wenn mit ihnen
eine Datei geteilt wird. Dementsprechend wird der Name mithilfe der kostenlosen API \url{
  https://www.purgomalum.com/} auf unangemessene Inhalte überprüft.\\
Ein weiteres identifizierendes Merkmal des Nutzers ist ein Avatar. Um auch hier ungewollte
Überraschungen zu vermeiden, wird lediglich ein Seed generiert, der dann durch die \href{
  https://www.dicebear.com/}{Dicebear} API in einen Avatar umgewandelt wird.
Wenn der Nutzer das Gerät zu einem bereits existierenden Nutzer hinzufügt, muss er den
Verbindungscode des Nutzers eingeben. Dieser Code wird dann an den Server gesendet, der
dann überprüft, ob der Code existiert. Wenn der Code existiert, wird das Gerät dem Nutzer
hinzugefügt, und der Code wird aus der Datenbank gelöscht. Wenn der Code nicht existiert,
wird eine Fehlermeldung angezeigt.\\
Nach der erfolgreichen Einrichtung wird sich die Statusanzeige (in der oberen rechten Ecke) schnell auf grün ändern.
Das bedeutet, dass das Gerät mit dem Server verbunden ist, und die App vollständig einsatzbereit ist.

\subsubsection{Kontakte verwalten}

hinzufügen und entfernen von Kontakten

\subsubsection{Dateien teilen}

\subsubsection{Einstellungen}

\subsubsection{App-Updates}
alles vcs, automatisiertes deployment, service worker update notification


\section{Aufteilung der Aufgaben}

\subsection*{Mitglieder}
Dezhong Zhuang, Quentin Frey, Leonhard Masche

\section{To-Do}
mirror to readme\\
Anleitung\\
techstack\\
Webtechnologien und Fallbacks (version graphics)\\
mvc muster\\
anschaulich! (Grafiken, Diagramme, ...)


\end{document}