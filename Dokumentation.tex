\documentclass[a4paper]{article}
\usepackage{graphicx}
\usepackage{pdfpages}
\usepackage{hyperref}
\usepackage{etoc}
\usepackage[ngerman]{babel}
\usepackage[T1]{fontenc}

% cSpell:words Filesharing techstack Dezhong Zhuang

\begin{document}


\input{Titelseite.tex}

\setcounter{tocdepth}{2}
\tableofcontents
\newpage

\section{Einleitung}
Unser Projekt ist eine Filesharing App (Webseite), mit der Dateien Peer-to-Peer,
also von Nutzer zu Nutzer, ohne zwischengeschalteten Server*, übertragen werden
können. Die App basiert auf modernen Web-Technologien, wie z.B.
\href{https://web.dev/push-notifications-web-push-protocol/}{Web Push},
\href{https://web.dev/learn/pwa/service-workers/}{Service Workers} und
\href{https://web.dev/progressive-web-apps/}{Progressive Web Apps}. Durch die
Design-Philosophie des
\href{https://developer.mozilla.org/en-US/docs/Glossary/Progressive_Enhancement}{Progressive
  Enhancement} werden aber auch ältere Browser unterstützt. Eine Besonderheit der
App ist es, dass sie dauerhafte Verbindungen durch Kontakte möglich macht.
Kontakte können zwischen mehreren Nutzern geknüpft werden, wobei jeder Nutzer
mehrere Geräte haben kann. Zum Schutz der Privatsphäre und Benutzersicherheit
werden keine identifizierbaren Informationen auf dem Server (in der Datenbank)
gespeichert und die Dateien im Transit Ende-zu-Ende verschlüsselt. Die
Motivation für dieses Projekt war das Problem, dass es keine einfache
Möglichkeit gibt, zwischen iOS / Android / Windows / Linux Geräten Dateien zu
teilen. Bestehende Webseiten nutzen hierfür einen Link, den der Empfänger öffnen
muss, um die Datei zu empfangen. Hierbei stellt sich dann wieder die Frage, wie
man diesen Link teilt. Um dieses Problem zu behandeln, implementiert die App ein
Kontakt-System, in dem sich Nutzer einmalig über einen 6-stelligen Code
verbinden und von nun an einfach miteinander Dateien teilen können. Dieses
System ist vor allem in einer Umgebung nützlich, in der man oft Dokumente mit
denselben Personen teilt, wie es z.B. in der Schule der Fall ist.

\section{Dokumentation}

\subsection{Implementierung}
Die App wurde in Form einer Webseite realisiert und ist somit auf allen Geräten
zugänglich, die einen Browser haben. Für die Entwicklung haben wir uns für das
Framework \href{https://kit.svelte.dev/}{SvelteKit} im NodeJS Ökosystem
entschieden. Dadurch muss die App nicht manuell in den Browser-kompatiblen
Sprachen geschrieben werden, sondern kann in einer modernen Sprache (Svelte in
Verbindung mit Typescript) geschrieben werden, wodurch die Entwicklung durch
vorgefertigte Implementierungsmuster und Tools stark vereinfacht wird. Die App
ist nach dem Muster einer Single-Page-Application aufgebaut, d.h. die Seite wird
nur einmal geladen, und alle weiteren Interaktionen finden über JavaScript
statt. Dadurch wird die App sehr schnell, da nur die Daten, die benötigt werden,
vom Server geladen werden müssen. Zusätzlich wird die App dadurch sehr
benutzerfreundlich, da der Nutzer nicht durch das Laden von verschiedenen Seiten
unterbrochen wird. Durch die optionale Installation als Progressive Web App
(PWA) kann die App auch auf dem Homescreen installiert werden, und verhält sich
dann wie eine native App.\\
Die Entwicklung der App findet in einer öffentlichen GitHub Repository statt.
Dieses Repository ist unter \url{https://github.com/leonhma/fileplay} zu finden,
und wird automatisch durch Integration mit Cloudflare auf den Adressen
\url{https://app.fileplay.me} (für den {main}-branch) und
\url{https://dev.fileplay.pages.dev} (für den {dev}-branch) zur Verfügung gestellt.\\
Der Programmcode für einen Microservice der die Kommunikation von Server zu
Client verwaltet ist unter \\\url{https://github.com/leonhma/fileplay-worker} zu
finden. Dieser Mikroservice nutzt APIs die nicht in SvelteKit verfügbar sind,
und wird deshalb separat gehosted.

\subsection{Architektur}
Die App ist nach dem MVC-Modell in drei Teile aufgeteilt: Frontend, Backend und
Datenbank. Das Frontend (View) ist die Webseite, die der Nutzer sieht und mit
der er interagiert. Das Backend (Controller) ist der Server, der die Webseite
ausliefert und die Anwendungslogik verwaltet, und die Datenbank ist das Modell,
in dem die Daten gespeichert werden. Sowohl das Frontend, als auch große Teile
des Backends werden vom Framework SvelteKit verwaltet. Dieses Framework erlaubt
es, die Webseite mit einer angepassten Syntax zu schreiben und
Entwickler-freundlich in Komponenten zu zerteilen. Zusätzlich bietet es eine
einfache Möglichkeit, Backend und Frontend Seite an Seite zu entwickeln.
Zusätzlich zu dem Backend-Code, der in SvelteKit geschrieben ist, gibt es noch
einen Microservice, der als \href{https://workers.cloudflare.com/}{Cloudflare
  Worker} in Typescript geschrieben ist. Dieser Verwaltet die WebSockets, die für
die Kommunikation von Server zu Client verwendet werden. Die Datenbank ist eine
SQLite Datenbank, welche mit dem Backend verbunden ist und Daten wie Geräte, Nutzer
oder Kontakte speichert.\\
Die einzelnen Teile der App (Backend, Datenbank und Microservice) werden alle
auf Cloudflare gehosted. Cloudflare bietet verschieden Web-Hosting-Services an,
darunter auch Pages, welches über eine GitHub Integration einfach mit dem
Build-Output von SvelteKit verbunden werden kann. Zusätzlich wird eine SQLite
Datenbank namens D1 verwendet, welche im Backend einfach durch Umgebungsvariablen
eingebunden werden kann. Der Microservice ist ein Cloudflare Worker, welcher
mithilfe der neuen WebSocket Hibernation API ressourcenschonend die Verbindungen
von Server zu Client verwaltet.\\
Die clientseitige Logik der App findet vor allem in Form von JavaScript
clientseitig statt. Wenn Daten vom Server abgefragt werden müssen, wie zum
Beispiel die Liste der Kontakte, wird dies über eine REST API gemacht. Dagegen findet
die Kommunikation von Server zu Client über WebSockets statt. Alternativ wird
hier auch eine Implementierung mit Web Push verwendet, jedoch wurde diese
aufgrund von Kompatibilitätsproblemen mit Edge und Firefox kurzfristig
deaktiviert. Die Dateiübertragung zwischen zwei Clients findet über WebRTC
statt. So kann die Datei (bis auf die Ausnahme einer Firewall) direkt zwischen
zwei Clients übertragen werden. Zwischen dem Front- und Backend steht noch ein
Service Worker, der im Browser der Nutzers läuft. Dieser ist für das Empfangen
von Nachrichten des Servers, und das cachen von Dateien zuständig.


\subsection{Authentifizierung}

Beim ersten Besuch der Webseite wird der Nutzer aufgefordert, bei der
Einrichtung einen Name für das Gerät und den verbundenen Nutzer einzugeben.
Diese Informationen werden dann an den Server gesendet, welcher dem Gerät eine
einzigartige Device ID zuweist. Diese ID wird dann in einem Cookie gespeichert,
und bei weiteren Besuchen der Webseite an den Server gesendet. Der Server kann
dann durch diese ID das Gerät identifizieren, und die Daten des Geräts aus der
Datenbank laden.\\
Um zu verhindern, dass ein Nutzer sich als ein anderes Gerät ausgibt, wird
zusätzlich zur Device ID ein Token generiert, welches auch einem Cookie
gespeichert wird. Dieses Token wird bei jeder Anfrage an den Server gesendet,
und der Server kann dann überprüfen, ob das Token, das mit der Signatur des
Servers unterzeichnet wurde, zu der Device ID passt.

\subsection{Geräte, Nutzer, Kontakte}

Um eine einfache Organisation und Nutzung der App zu ermöglichen, wird zwischen Geräten,
Nutzern und Kontakten unterschieden. Ein Gerät ist ein Endgerät, auf dem die App
installiert ist. Ein Nutzer ist eine Person, die die App nutzt. Ein Nutzer kann
mehrere Geräte besitzen, ein Gerät dagegen kann nur einem Nutzer zugeordnet werden. Ein Kontakt repräsentiert
eine Verbindung zwischen zwei Nutzern, welche wiederum unbegrenzt viele Kontakte haben können.\\
Diese Verknüpfungen von Nutzern und Geräten (one-to-many) und Nutzern
untereinander, als Kontakte (many-to-many), können durch das Generieren und
Einlösen von sechsstelligen Verbindungscodes realisiert werden. Wenn ein Nutzer
einen Code generiert, wird dieser Code in der Datenbank gespeichert und kann diesen
Code an einen anderen Nutzer weitergeben. Wenn der andere
Nutzer diesen Code eingibt, wird eine Verbindung zwischen den beiden Nutzern
hergestellt und der Code wird aus der Datenbank gelöscht.


\subsection{Filesharing}
Wenn ein Nutzer eine Datei teilen möchte, wählt er einen verfügbaren Kontakt
aus, dessen ID dann in einer Anfrage an den Server gesendet wird. Dieser schickt
diese Anfrage anschließend per WebSocket (oder Web Push) an die einzelnen Geräte des
Kontakts. Wenn ein Gerät die Anfrage akzeptiert, schickt dieses Gerät eine
Antwort mit der PeerJS-Adresse des Geräts, an das die Datei übertragen werden soll,
an den Server. Diese Antwort enthält auch den Public Key des Geräts, der für die
Verschlüsselung der Datei verwendet wird. Der Server leitet diese Antwort dann
an den ursprünglichen Nutzer weiter, der die Datei dann an die PeerJS-Adresse
senden kann.

\subsection{User-Story}

\subsubsection{Einrichtung}
Wenn ein Nutzer die App zum ersten Mal öffnet, wird er aufgefordert, einen Namen
für das Gerät anzugeben, und den Typ des Geräts auszuwählen. Dies dient
lediglich der erleichterten späteren Identifikation der Geräte durch den Nutzer
selbst.\\
Zusätzlich zu den Daten des Geräts muss der Nutzer entweder einen neuen Nutzer
erstellen, oder das Gerät zu einem Bereits existierenden hinzufügen. Wenn der
Nutzer einen neuen erstellt, Kann er diesem einen Namen geben. Dieser Name wird
auch für Kontakte sichtbar sein, wenn mit ihnen eine Datei geteilt wird.
Dementsprechend wird der Name mithilfe der kostenlosen API \url{
  https://www.purgomalum.com/} auf unangemessene Inhalte überprüft.\\
Ein weiteres identifizierendes Merkmal des Nutzers ist ein Avatar. Um auch hier
ungewollte Überraschungen zu vermeiden, wird lediglich ein Seed generiert, der
dann durch die \href{ https://www.dicebear.com/}{Dicebear} API in einen Avatar
umgewandelt wird. Wenn der Nutzer das Gerät zu einem bereits existierenden
Nutzer hinzufügt, muss er den Verbindungscode eingeben, den der Nutzer generiert
hat. Dieser Code wird dann an den Server gesendet, der dann überprüft, ob der
Code existiert. Wenn der Code existiert, wird das Gerät dem Nutzer hinzugefügt,
und der Code wird aus der Datenbank gelöscht. Wenn der Code nicht existiert,
wird eine Fehlermeldung angezeigt.\\
Nach der erfolgreichen Einrichtung wird sich die Statusanzeige (in der oberen
rechten Ecke) schnell auf grün ändern. Das bedeutet, dass das Gerät mit dem
Server verbunden ist, und die App vollständig einsatzbereit ist.

\subsubsection{Kontakte verwalten}

hinzufügen und entfernen von Kontakten

\subsubsection{Dateien teilen}
select, send, online contacts, error handling

\subsubsection{Einstellungen}
hinzufügen von geräten, linking code, infos ändern

\subsubsection{App-Updates}
alles vcs, automatisiertes deployment, service worker update notification


\section{Aufteilung der Aufgaben}

\subsection{Mitglieder}
Dezhong Zhuang, Quentin Frey, Leonhard Masche

\subsubsection{Leonhard Masche (\href{https://github.com/leonhma}{@leonhma})}
\begin{itemize}
  \item Infrastruktur und DevOps: Ich habe die Struktur des Projektes
        eingerichtet, und die Infrastruktur auf Cloudflare konfiguriert. Dazu
        gehört die Konfiguration des Domainnamen und DNS, sowie das Einrichten
        der Datenbank, deren Integration mit dem Backend, sowie die CI/CD
        Integration mit GitHub. Implementierungen sind: '/src/lib/db.ts',
        '/src/lib/server/db.ts', '/wrangler.toml', '/migrations/*'
  \item API: Ich habe die REST API entwickelt, die z.B. das Auflisten von
        Kontakten und Geräten, Anfragen von Datei-Sharing und das Verbinden von
        Nutzern untereinander und mit Geräten ermöglicht. Im Projekt sind all
        diese Dateien unter '/src/routes/api' zu finden.
  \item Authentifizierung: Ich habe die Authentifizierung implementiert, die
        dafür sorgt, dass nur authentifizierte Geräte mit dem Server
        kommunizieren können. Dazu gehört die Generierung von Tokens und
        Device-IDs, sowie die Überprüfung dieser. Die Implementation ist unter
        '/src/lib/server/crypto.ts' zu finden.
  \item Server Side Notifications: Schon beim Thema Backend angekommen, habe ich
        auch das System für die Benachrichtigungen konzeptioniert und
        implementiert. Dieses System besteht aus einer Funktion auf dem Server,
        die eine Nachricht adaptiv über einen der beiden Kanäle (WebSockets oder
        Web Push) an den Client überliefert, sowie der clientseitige Logik, um
        die Verbindung für die Nachrichten zu initialisieren und aktiv zu
        halten. Die Implementation befindet sich unter
        '/src/lib/server/notifications.ts'.
  \item Web Push: Als einer der beiden Kanäle für die Benachrichtigungen habe
        ich Web Push implementiert. Dazu gehört auch die Authentifizierung mit
        dem VAPID-Keypair des Servers. (siehe '/scripts/genenrate-keys.js').
        Dieser Kanal ist vor allem für die Benachrichtigungen auf mobilen
        Geräten interessant, da er stromsparend Benachrichtigungen liefert, auch
        wenn das Gerät sich nicht auf der Webseite befindet. Die Implementation
        findet sich zum Teil in '/src/lib/server/notifications.ts' und zum Teil
        im Service Worker. Aufgrund von unergründbaren Problemen bei der
        Kompatibilität mit anderen Browsern (nicht Google Chrome), musste dieses
        Feature (zumindest für die Vorführung) aber deaktiviert werden.
  \item Service Worker: Zwischen Client und Server habe ich auch den Service
        Worker geschrieben, der das Caching der Webseite für eine schnellere
        Ladezeit mithilfe WorkBox verwaltet, und eine wichtige Rolle bei den
        Push Notifications spielt geschrieben. Der Service Worker befindet sich
        unter '/src/sw.ts'.
  \item WebSockets: Als zweiter Kanal für die Benachrichtigungen habe ich die
        finale Version der WebSockets implementiert. Zu dieser
        Benachrichtigungsmethode gehört auch der in 'leonhma/fileplay-worker'
        aufzufindende Cloudflare Worker, der ein Durable Object verwaltet,
        welches die WebSocket Verbindung dem Server gegenüber zugänglich macht.
  \item Als ein weiterer Teil den Notifications, habe ich mich mit der
        Übertragung von Nachrichten zwischen Service Worker und Client
        auseinandergesetzt. Dazu gehört auch, die per Web Push empfangenen
        Nachrichten an den Client (die Webseite) weiterzuleiten, um auf sie
        reagieren zu können. Die relevanten Stücke Code befinden sich in
        '/src/sw.ts' und /src/lib/messages.ts'.
  \item Notifications: Als letzter Teil der Notifications habe ich mich um die
        Anzeige von interagierbaren Benachrichtigungen gekümmert. Das sind zum
        einen die Benachrichtigungen die über den Service Worker und Web Push im
        OS-Tray angezeigt werden, aber auch die Nachrichten, die in der App im
        Notification Drawer sichtbar sind. Bei den In-App Benachrichtigungen
        habe ich mich um die klickbaren Aktionen und deren Ausführung bemüht,
        welche stark die Notification API im Service Worker nachahmen. Die
        relevanten Dateien sind '/src/lib/stores/Dialog.ts' und
        '/src/lib/components/NotificationsDrawer.svelte'.
  \item Ein Teil des UIs den Ich gestaltet habe, ist der Einrichtungs-Dialog.
        Dieser ist eng Verbunden mit der Authentifizierung und Der REST API. Die
        relevante Datei ist '/src/lib/dialogs/SetupDialog.svelte'.
\end{itemize}



\section{To-Do}
mirror to readme\\
Anleitung\\
techstack\\
Webtechnologien und Fallbacks (version graphics)\\
mvc muster\\
anschaulich! (Grafiken, Diagramme, ...)


\end{document}